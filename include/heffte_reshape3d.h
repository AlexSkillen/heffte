/*
    -- HEFFTE (version 0.2) --
       Univ. of Tennessee, Knoxville
       @date
*/

/** @class */
// Reshape3d class

#ifndef HEFFTE_RESHAPE3D_H
#define HEFFTE_RESHAPE3D_H

#include <mpi.h>
#include "heffte_utils.h"
#include "heffte_common.h"
#include "heffte_pack3d.h"
#include "heffte_geometry.h"

namespace HEFFTE {

  /*!
   * The class Reshape3d is in charge of data reshape, starting from the input data to the first
   * direction, and going to every direction to finalize by reshaping the computed FFT into the output
   * shape. Objects can be created as follows: new Reshape3d(MPI_Comm user_comm)
   * @param user_comm  MPI communicator for the P procs which own the data
   */

template <class U>
class Reshape3d {
 public:
  int collective;         // 0 = point-to-point MPI, 1 = collective all2all
  int packflag;           // 0 = array, 1 = pointer, 2 = memcpy
  int64_t memusage;       // memory usage in bytes

  enum heffte_memory_type_t memory_type;

  Reshape3d(MPI_Comm);
  ~Reshape3d();

  void setup(int in_ilo, int in_ihi, int in_jlo, int in_jhi, int in_klo, int in_khi,
             int out_ilo, int out_ihi, int out_jlo, int out_jhi, int out_klo, int out_khi,
             int nqty, int user_permute, int user_memoryflag, int &user_sendsize, int &user_recvsize);

  template <class T>
  void reshape(T *in, T *out, T *user_sendbuf, T *user_recvbuf);

 private:
  MPI_Comm world;
  int me,nprocs,me_newcomm,nprocs_newcomm;
  int setupflag;

  class Memory *memory;
  class Memory *memory_cpu;
  class Error *error;

  // details of how to perform a 3d reshape

  int permute;                      // permutation setting = 0,1,2
  int memoryflag;                   // 0 = user-provided bufs, 1 = internal

  // point to point communication

  int nrecv;                        // # of recvs from other procs
  int nsend;                        // # of sends to other procs
  int self;                         // whether I send/recv with myself

  int *send_offset;                 // extraction loc for each send
  int *send_size;                   // size of each send message
  int *send_proc;                   // proc to send each message to
  struct pack_plan_3d *packplan;    // pack plan for each send message
  int *recv_offset;                 // insertion loc for each recv
  int *recv_size;                   // size of each recv message
  int *recv_proc;                   // proc to recv each message from
  int *recv_bufloc;                 // offset in scratch buf for each recv
  MPI_Request *request;             // MPI request for each posted recv
  struct pack_plan_3d *unpackplan;  // unpack plan for each recv message

  // collective communication

  int ngroup;                       // # of procs in my collective comm group
  int *pgroup;                      // list of ranks in my comm group
  MPI_Comm newcomm;                 // communicator for my comm group

  int *sendcnts;                    // args for MPI_All2all()
  int *senddispls;
  int *sendmap;
  int *recvcnts;
  int *recvdispls;
  int *recvmap;

  // memory for reshape sends and recvs and All2all
  // either provided by caller or allocated internally

  U *sendbuf;              // send buffer
  U *recvbuf;              // recv buffer

  // which pack & unpack functions to use

  void (*pack)(U *, U *, struct pack_plan_3d *);
  void (*unpack)(U *, U *, struct pack_plan_3d *);

  // collision between 2 regions

  struct extent_3d {
    int ilo,ihi,isize;
    int jlo,jhi,jsize;
    int klo,khi,ksize;
  };

  int collide(struct extent_3d *, struct extent_3d *, struct extent_3d *);
};

}

namespace heffte {


/*!
 * \brief Base reshape interface.
 */
class reshape3d_base{
public:
    //! \brief Default virtual destructor.
    virtual ~reshape3d_base() = default;
    //! \brief Apply the reshape, single precision.
    virtual void apply(float const source[], float destination[]) const = 0;
    //! \brief Apply the reshape, double precision.
    virtual void apply(double const source[], double destination[]) const = 0;
    //! \brief Apply the reshape, single precision complex.
    virtual void apply(std::complex<float> const source[], std::complex<float> destination[]) const = 0;
    //! \brief Apply the reshape, double precision complex.
    virtual void apply(std::complex<double> const source[], std::complex<double> destination[]) const = 0;
};

/*!
 * \brief Reshape algorithm based on the MPI_Alltoallv() method.
 *
 * \tparam backend is the heffte backend
 * \tparam packer the packer algorithms to use in arranging the sub-boxes into the global send/recv buffer
 */
template<typename backend, template<typename device> class packer>
class reshape3d_alltoallv : public reshape3d_base{
public:
    //! \brief Destructor, frees the comm generated by the constructor.
    ~reshape3d_alltoallv(){ mpi::comm_free(comm); }
    //! \brief Factory method, use to construct instances of the class.
    template<typename b, template<typename d> class p> friend std::unique_ptr<reshape3d_alltoallv<b, p>>
    make_reshape3d_alltoallv(std::vector<box3d> const&, std::vector<box3d> const&, MPI_Comm const);

    //! \brief Apply the reshape operations, single precision overload.
    void apply(float const source[], float destination[]) const override final{
        apply_base(source, destination);
    }
    //! \brief Apply the reshape operations, double precision overload.
    void apply(double const source[], double destination[]) const override final{
        apply_base(source, destination);
    }
    //! \brief Apply the reshape operations, single precision complex overload.
    void apply(std::complex<float> const source[], std::complex<float> destination[]) const override final{
        apply_base(source, destination);
    }
    //! \brief Apply the reshape operations, double precision complex overload.
    void apply(std::complex<double> const source[], std::complex<double> destination[]) const override final{
        apply_base(source, destination);
    }

    //! \brief Templated apply algorithm for all scalar types.
    template<typename scalar_type>
    void apply_base(scalar_type const source[], scalar_type destination[]) const;

private:
    /*!
     * \brief Private constructor that accepts a set of arrays that have been pre-computed by the factory.
     */
    reshape3d_alltoallv(MPI_Comm master_comm, std::vector<int> const &pgroup,
                        std::vector<int> &&send_offset, std::vector<int> &&send_size, std::vector<int> const &send_proc,
                        std::vector<int> &&recv_offset, std::vector<int> &&recv_size, std::vector<int> const &recv_proc,
                        std::vector<pack_plan_3d> &&packplan, std::vector<pack_plan_3d> &&unpackplan);

    MPI_Comm const comm;
    int const me, nprocs;

    std::vector<int> const send_offset;   // extraction loc for each send
    std::vector<int> const send_size;     // size of each send message
    std::vector<int> const recv_offset;   // insertion loc for each recv
    std::vector<int> const recv_size;     // size of each recv message
    int const send_total, recv_total;

    std::vector<pack_plan_3d> const packplan, unpackplan;

    struct iotripple{
        std::vector<int> counts, displacements, map;
        iotripple(std::vector<int> const &pgroup, std::vector<int> const &proc, std::vector<int> const &sizes) :
            counts(pgroup.size(), 0), displacements(pgroup.size(), 0), map(pgroup.size(), -1)
        {
            int offset = 0;
            for(size_t src = 0; src < pgroup.size(); src++){
                for(size_t i=0; i<proc.size(); i++){
                    if (proc[i] != pgroup[src]) continue;
                    counts[src] = sizes[i];
                    displacements[src] = offset;
                    offset += sizes[i];
                    map[src] = i;
                }
            }
        }

    };

    iotripple const send, recv;
};


/*!
 * \brief Factory method that all the necessary work to establish the communication patterns.
 *
 * The purpose of the factory method is to isolate the initialization code and ensure that the internal
 * state of the class is minimal and const-correct, i.e., objects do not hold onto data that will not be
 * used in a reshape apply and the data is labeled const to prevent accidental corruption.
 *
 * \tparam backend the backend to use for the reshape operations
 * \tparam packer is the packer to use to parts of boxes into global send/recv buffer
 *
 * \param input_boxes list of all input boxes across all ranks in the comm
 * \param output_boxes list of all output boxes across all ranks in the comm
 * \param comm the communicator associated with all the boxes
 *
 * \returns unique_ptr containing an instance of the heffte::reshape3d_alltoallv
 *
 * Note: the input and output boxes associated with this rank are located at position
 * mpi::comm_rank() in the respective lists.
 */
template<typename backend, template<typename device> class packer = direct_packer>
std::unique_ptr<reshape3d_alltoallv<backend, packer>>
make_reshape3d_alltoallv(std::vector<box3d> const &input_boxes,
                         std::vector<box3d> const &output_boxes,
                         MPI_Comm const);

}

#endif
